<h1 id="目录">目录</h1>

[ListView优化方案](#ListView优化方案)

[android中的动画有哪几类，它们的特点和区别是什么](#android中的动画有哪几类，它们的特点和区别是什么)

[android中有哪几种解析xml的类？官方推荐哪种？以及它们的原理和区别](#android中有哪几种解析xml的类？官方推荐哪种？以及它们的原理和区别)

[Android的数据存储方式](#Android的数据存储方式)

[activity的启动模式有哪些？是什么含义？](#activity的启动模式有哪些？是什么含义？)

[Activity的生命周期](#Activity的生命周期)

[activity在屏幕旋转时的生命周期](#activity在屏幕旋转时的生命周期)

[Service的生命周期](#Service的生命周期)

[注册广播有几种方式，这些方式有何优缺点？](#注册广播有几种方式，这些方式有何优缺点？)

[请解释下在单线程模型中Message、Handler、Message Queue、Looper之间的关系](#请解释下在单线程模型中Message、Handler、MessageQueue、Looper之间的关系)

[说说mvc模式的原理，它在android中的运用,android的官方建议应用程序的开发采用mvc模式。何谓mvc？](#说说mvc模式的原理，它在android中的运用,android的官方建议应用程序的开发采用mvc模式。何谓mvc？)

[什么是ANR，如何避免它？](#什么是ANR，如何避免它？)

[什么情况会导致ForceClose？如何避免？能否捕获导致其的异常？](#什么情况会导致ForceClose？如何避免？能否捕获导致其的异常？)

[描述一下android的系统架构](#描述一下android的系统架构)

[AIDL的全称是什么？如何工作？能处理哪些类型的数据？](#AIDL的全称是什么？如何工作？能处理哪些类型的数据？)

[请解释下Android程序运行时权限与文件系统权限的区别。](#请解释下Android程序运行时权限与文件系统权限的区别。)

[Android的dvm中进程和Linux的进程,应用程序的进程是否为同一个概念](#Android的dvm中进程和Linux的进程,应用程序的进程是否为同一个概念)

[谈谈Android的IPC（进程间通信）机制](#谈谈Android的IPC（进程间通信）机制)

[NDK是什么](#NDK是什么)

[StringBuilder与StringBuffer的区别](#StringBuilder与StringBuffer的区别)

[如何理解Activity，View，Window三者之间的关系？](#如何理解Activity，View，Window三者之间的关系？)

[View的绘制流程](#View的绘制流程)

[Touch事件的传递机制](#Touch事件的传递机制)

[](#)

[](#)

[](#)

[](#)

[](#)

[](#)

[](#)

[](#)

[](#)



<h2 id="ListView优化方案">
ListView优化方案
<a href="http://blog.csdn.net/fenghai22/article/details/44173057" >
(更多参考)</a></h2>

[回到目录](#目录)

```
1、复用convertView
2、缓存item条目的引用，减少findViewbyId—>ViewHolder
3、数据的 分页/分批 加载：对大量的数据进行分页展示，对不同的滚动状态进行分别处理，在快速滑动状态不加载数据
4、图片的缓存，需要解决图片错位问题—>推荐使用成熟框架Glide或Picasso
```


<h2 id="android中的动画有哪几类，它们的特点和区别是什么">
android中的动画有哪几类，它们的特点和区别是什么
<a href="http://blog.csdn.net/yanbober/article/details/46481171" >
(更多参考)</a></h2>

[回到目录](#目录)

```
FrameAnimation（逐帧动画）：将多张图片组合起来进行播放，类似于早期电影的工作原理，很多静态图片不断切换的效果类似gif图

TweenAnimation（补间动画）：知道开始和结束，将中间的过程给补充起来，组件从初始状态变成结束状态，为了让改变看起来更平滑【平移动画：TranslateAnimation、缩放动画：ScaleAnimation、透明动画：AlphaAnimation、旋转动画：RotateAnimation】。

PropertyAnimation（属性动画）：属性动画不再仅仅是一种视觉效果了，而是一种不断地对值进行操作的机制，并将值赋到指定对象的指定属性上，可以是任意对象的任意属性。控件位置也发生了改变，属性动画只对Android 3.0（API 11）以上版本的Android系统才有效，这种动画可以设置给任何Object，包括那些还没有渲染到屏幕上的对象。这种动画是可扩展的，可以让你自定义任何类型和属性的动画。


```


<h2 id="android中有哪几种解析xml的类？官方推荐哪种？以及它们的原理和区别">
android中有哪几种解析xml的类？官方推荐哪种？以及它们的原理和区别
<a href="" >
(更多参考)</a></h2>

[回到目录](#目录)

```
XML解析主要有三种方式，SAX、DOM、PULL。常规在PC上开发我们使用Dom相对轻松些，但一些性能敏感的数据库或手机上还是主要采用SAX方式，SAX读取是单向的，优点:不占内存空间、解析属性方便，但缺点就是对于套嵌多个分支来说处理不是很方便。而DOM方式会把整个XML文件加载到内存中去，这里Android开发网提醒大家该方法在查找方面可以和XPath很好的结合如果数据量不是很大推荐使用，而PULL常常用在J2ME对于节点处理比较好，类似SAX方式，同样很节省内存，在J2ME中我们经常使用的KXML库来解析。
```


<h2 id="Android的数据存储方式">
Android的数据存储方式
<a href="" >
(更多参考)</a></h2>

[回到目录](#目录)


```
1.SharedPreferences：它是 Android提供的用来存储一些简单配置信息的一种机制，例如：登录用户的用户名与密码。其采用了Map数据结构来存储数据，以键值的方式存储，可以简单的读取与写入
2.文件存储：在Android中读取/写入文件的方法，与 Java中实现I/O的程序是完全一样的，提供了openFileInput()和openFileOutput()方法来读取设备上的文件
3.SQLite数据库存储：
4.ContentProvider存储：
5.网络存储：网络存储方式，需要与Android 网络数据包打交道
```


<h2 id="activity的启动模式有哪些？是什么含义？">
activity的启动模式有哪些？是什么含义？
<a href="" >
(更多参考)</a></h2>

[回到目录](#目录)


```
standard 模式
这是默认模式，每次激活Activity时都会创建Activity实例，并放入任务栈中。使用场景：大多数Activity。

singleTop 模式
如果在任务的栈顶正好存在该Activity的实例，就重用该实例( 会调用实例的 onNewIntent() )，否则就会创建新的实例并放入栈顶，即使栈中已经存在该Activity的实例，只要不在栈顶，都会创建新的实例。使用场景如新闻类或者阅读类App的内容页面。

singleTask 模式
如果在栈中已经有该Activity的实例，就重用该实例(会调用实例的 onNewIntent() )。重用时，会让该实例回到栈顶，因此在它上面的实例将会被移出栈。如果栈中不存在该实例，将会创建新的实例放入栈中。使用场景如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。

singleInstance 模式
在一个新栈中创建该Activity的实例，并让多个应用共享该栈中的该Activity实例。一旦该模式的Activity实例已经存在于某个栈中，任何应用再激活该Activity时都会重用该栈中的实例( 会调用实例的 onNewIntent() )。其效果相当于多个应用共享一个应用，不管谁激活该 Activity 都会进入同一个应用中。使用场景如闹铃提醒，将闹铃提醒与闹铃设置分离。singleInstance不要用于中间页面，如果用于中间页面，跳转会有问题，比如：A -> B (singleInstance) -> C，完全退出后，在此启动，首先打开的是B。
```


<h2 id="Activity的生命周期">
Activity的生命周期
<a href="" >
(更多参考)</a></h2>

[回到目录](#目录)

```
activity的生命周期方法有：onCreate()、onStart()、onReStart()、onResume()、onPause()、onStop()、onDestory()；

可见生命周期：从onStart()直到系统调用onStop()

前台生命周期：从onResume()直到系统调用onPause()
```


<h2 id="activity在屏幕旋转时的生命周期">
activity在屏幕旋转时的生命周期
<a href="" >
(更多参考)</a></h2>

[回到目录](#目录)


```
答：不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次；设置Activity的android:configChanges="orientation"时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次；设置Activity的android:configChanges="orientation|keyboardHidden"时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法
```


<h2 id="Service的生命周期">
Service的生命周期
<a href="" >
(更多参考)</a></h2>

[回到目录](#目录)


```

```


<h2 id="注册广播有几种方式，这些方式有何优缺点？">
注册广播有几种方式，这些方式有何优缺点？
<a href="" >
(更多参考)</a></h2>

[回到目录](#目录)


第一种:在清单文件中声明:常驻型，也就是说当应用程序关闭后，如果有信息广播来，程序也会被系统调用自动运行。
```
  <receiver
        android:name=".MyReceiver"
        android:enabled="true"
        android:exported="true">
        <!-- 静态注册广播 -->
        <!-- intent过滤器,指定可以匹配哪些intent, 一般需要定义action 可以是自定义的也可是系统的 -->
        <intent-filter>
        <!--action-->
            <action android:name="com.broadcast.test" />
       </intent-filter>
 </receiver>
```

第二种：使用代码进行注册:不是常驻型广播，也就是说广播跟随程序的生命周期。
```
IntentFilter filter =  new IntentFilter("android.provider.Telephony.SMS_RECEIVED");
IncomingSMSReceiver receiver = new IncomgSMSReceiver();
registerReceiver(receiver.filter);
```


<h2 id="请解释下在单线程模型中Message、Handler、MessageQueue、Looper之间的关系">
请解释下在单线程模型中Message、Handler、MessageQueue、Looper之间的关系
<a href="" >
(更多参考)</a></h2>

[回到目录](#目录)

```
答：简单的说，Handler获取当前线程中的looper对象，looper用来从存放Message的MessageQueue中取出Message，再有Handler进行Message的分发和处理.

Message Queue(消息队列)：用来存放通过Handler发布的消息，通常附属于某一个创建它的线程，可以通过Looper.myQueue()得到当前线程的消息队列

Handler：可以发布或者处理一个消息或者操作一个Runnable，通过Handler发布消息，消息将只会发送到与它关联的消息队列，然也只能处理该消息队列中的消息

Looper：是Handler和消息队列之间通讯桥梁，程序组件首先通过Handler把消息传递给Looper，Looper把消息放入队列。Looper也把消息队列里的消息广播给所有的

Handler：Handler接受到消息后调用handleMessage进行处理

Message：消息的类型，在Handler类中的handleMessage方法中得到单个的消息进行处理

在单线程模型下，为了线程通信问题，Android设计了一个Message Queue(消息队列)， 线程间可以通过该Message Queue并结合Handler和Looper组件进行信息交换。下面将对它们进行分别介绍：

1. Message

    Message消息，理解为线程间交流的信息，处理数据后台线程需要更新UI，则发送Message内含一些数据给UI线程。

2. Handler

    Handler处理者，是Message的主要处理者，负责Message的发送，Message内容的执行处理。后台线程就是通过传进来的 Handler对象引用来sendMessage(Message)。而使用Handler，需要implement 该类的 handleMessage(Message)方法，它是处理这些Message的操作内容，例如Update UI。通常需要子类化Handler来实现handleMessage方法。

3. Message Queue

    Message Queue消息队列，用来存放通过Handler发布的消息，按照先进先出执行。

    每个message queue都会有一个对应的Handler。Handler会向message queue通过两种方法发送消息：sendMessage或post。这两种消息都会插在message queue队尾并按先进先出执行。但通过这两种方法发送的消息执行的方式略有不同：通过sendMessage发送的是一个message对象,会被 Handler的handleMessage()函数处理；而通过post方法发送的是一个runnable对象，则会自己执行。

4. Looper

    Looper是每条线程里的Message Queue的管家。Android没有Global的Message Queue，而Android会自动替主线程(UI线程)建立Message Queue，但在子线程里并没有建立Message Queue。所以调用Looper.getMainLooper()得到的主线程的Looper不为NULL，但调用Looper.myLooper() 得到当前线程的Looper就有可能为NULL。对于子线程使用Looper，API Doc提供了正确的使用方法：这个Message机制的大概流程：

    1. 在Looper.loop()方法运行开始后，循环地按照接收顺序取出Message Queue里面的非NULL的Message。

    2. 一开始Message Queue里面的Message都是NULL的。当Handler.sendMessage(Message)到Message Queue，该函数里面设置了那个Message对象的target属性是当前的Handler对象。随后Looper取出了那个Message，则调用 该Message的target指向的Hander的dispatchMessage函数对Message进行处理。在dispatchMessage方法里，如何处理Message则由用户指定，三个判断，优先级从高到低：

    1) Message里面的Callback，一个实现了Runnable接口的对象，其中run函数做处理工作；

    2) Handler里面的mCallback指向的一个实现了Callback接口的对象，由其handleMessage进行处理；

    3) 处理消息Handler对象对应的类继承并实现了其中handleMessage函数，通过这个实现的handleMessage函数处理消息。

    由此可见，我们实现的handleMessage方法是优先级最低的！

    3. Handler处理完该Message (update UI) 后，Looper则设置该Message为NULL，以便回收！

    在网上有很多文章讲述主线程和其他子线程如何交互，传送信息，最终谁来执行处理信息之类的，个人理解是最简单的方法——判断Handler对象里面的Looper对象是属于哪条线程的，则由该线程来执行！

    1. 当Handler对象的构造函数的参数为空，则为当前所在线程的Looper；

2. Looper.getMainLooper()得到的是主线程的Looper对象，Looper.myLooper()得到的是当前线程的Looper对象。
```


<h2 id="说说mvc模式的原理，它在android中的运用,android的官方建议应用程序的开发采用mvc模式。何谓mvc？">
说说mvc模式的原理，它在android中的运用,android的官方建议应用程序的开发采用mvc模式。何谓mvc？
<a href="#" >
(更多参考)</a></h2>

[回到目录](#目录)

```
mvc是model,view,controller的缩写，mvc包含三个部分：

　　模型（model）对象：是应用程序的主体部分，所有的业务逻辑都应该写在该层。

　　视图（view）对象：是应用程序中负责生成用户界面的部分。也是在整个mvc架构中用户唯一可以看到的一层，接收用户的输入，显示处理结果。

　　控制器（control）对象：是根据用户的输入，控制用户界面数据显示及更新model对象状态的部分，控制器更重要的一种导航功能，响应用户出发的相关事件，交给m层处理。

　　android鼓励弱耦合和组件的重用，在android中mvc的具体体现如下：

　　1)视图层（view）：一般采用xml文件进行界面的描述，使用的时候可以非常方便的引入，当然，如果你对android了解的比较的多了话，就一定可以想到在android中也可以使用JavaScript+html等的方式作为view层，当然这里需要进行java和javascript之间的通信，幸运的是，android提供了它们之间非常方便的通信实现。

　　2)控制层（controller）：android的控制层的重任通常落在了众多的acitvity的肩上，这句话也就暗含了不要在acitivity中写代码，要通过activity交割model业务逻辑层处理，这样做的另外一个原因是android中的acitivity的响应时间是5s，如果耗时的操作放在这里，程序就很容易被回收掉。

　　3)模型层（model）：对数据库的操作、对网络等的操作都应该在model里面处理，当然对业务计算等操作也是必须放在的该层的。
```


<h2 id="什么是ANR，如何避免它？">
什么是ANR，如何避免它？
<a href="#" >
(更多参考)</a></h2>

[回到目录](#目录)

```
ANR：Application Not Responding。在Android中，活动管理器和窗口管理器这两个系统服务负责监视应用程序的响应，当用户操作的在5s内应用程序没能做出反应，BroadcastReceiver在10秒内没有执行完毕，就会出现应用程序无响应对话框，这既是ANR。
避免方法：Activity应该在它的关键生命周期方法（如onCreate()和onResume()）里尽可能少的去做创建操作。潜在的耗时操作，例如网络或数据库操作，或者高耗时的计算如改变位图尺寸，应该在子线程里（或者异步方式）来完成。主线程应该为子线程提供一个Handler，以便完成时能够提交给主线程。
```

<h2 id="什么情况会导致ForceClose？如何避免？能否捕获导致其的异常？">
什么情况会导致ForceClose？如何避免？能否捕获导致其的异常？
<a href="#" >
(更多参考)</a></h2>

[回到目录](#目录)

```
程序出现异常，比如nullpointer。
避免：编写程序时逻辑连贯，思维缜密。能捕获异常，在logcat中能看到异常信息
```


<h2 id="描述一下android的系统架构">
描述一下android的系统架构
<a href="#" >
(更多参考)</a></h2>

[回到目录](#目录)

```
android系统架构分从下往上为linux 内核层、运行库、应用程序框架层、和应用程序层。

linuxkernel：负责硬件的驱动程序、网络、电源、系统安全以及内存管理等功能。

libraries和 android runtime：libraries：即c/c++函数库部分，大多数都是开放源代码的函数库，例如webkit（引擎），该函数库负责 android网页浏览器的运行，例如标准的c函数库libc、openssl、sqlite等，当然也包括支持游戏开发2dsgl和 3dopengles，在多媒体方面有mediaframework框架来支持各种影音和图形文件的播放与显示，例如mpeg4、h.264、mp3、 aac、amr、jpg和png等众多的多媒体文件格式。android的runtime负责解释和执行生成的dalvik格式的字节码。

　applicationframework（应用软件架构），java应用程序开发人员主要是使用该层封装好的api进行快速开发。

　　applications:该层是java的应用程序层，android内置的googlemaps、e-mail、即时通信工具、浏览器、mp3播放器等处于该层，java开发人员开发的程序也处于该层，而且和内置的应用程序具有平等的位置，可以调用内置的应用程序，也可以替换内置的应用程序。

　　上面的四个层次，下层为上层服务，上层需要下层的支持，调用下层的服务，这种严格分层的方式带来的极大的稳定性、灵活性和可扩展性，使得不同层的开发人员可以按照规范专心特定层的开发。

android应用程序使用框架的api并在框架下运行，这就带来了程序开发的高度一致性，另一方面也告诉我们，要想写出优质高效的程序就必须对整个 applicationframework进行非常深入的理解。精通applicationframework，你就可以真正的理解android的设计和运行机制，也就更能够驾驭整个应用层的开发。
```


<h2 id="AIDL的全称是什么？如何工作？能处理哪些类型的数据？">
AIDL的全称是什么？如何工作？能处理哪些类型的数据？
<a href="#" >
(更多参考)</a></h2>

[回到目录](#目录)

```
答：全称是：Android Interface Define Language

在Android中, 每个应用程序都可以有自己的进程. 在写UI应用的时候, 经常要用到Service. 在不同的进程中, 怎样传递对象呢?显然, Java中不允许跨进程内存共享. 因此传递对象, 只能把对象拆分成操作系统能理解的简单形式, 以达到跨界对象访问的目的. 在J2EE中,采用RMI的方式, 可以通过序列化传递对象. 在Android中, 则采用AIDL的方式. 理论上AIDL可以传递Bundle,实际上做起来却比较麻烦。

AIDL(AndRoid接口描述语言)是一种借口描述语言; 编译器可以通过aidl文件生成一段代码，通过预先定义的接口达到两个进程内部通信进程的目的. 如果需要在一个Activity中, 访问另一个Service中的某个对象, 需要先将对象转化成AIDL可识别的参数(可能是多个参数), 然后使用AIDL来传递这些参数, 在消息的接收端, 使用这些参数组装成自己需要的对象.

AIDL的IPC的机制和COM或CORBA类似, 是基于接口的，但它是轻量级的。它使用代理类在客户端和实现层间传递值. 如果要使用AIDL, 需要完成2件事情: 1. 引入AIDL的相关类.; 2. 调用aidl产生的class.

AIDL的创建方法:

AIDL语法很简单,可以用来声明一个带一个或多个方法的接口，也可以传递参数和返回值。 由于远程调用的需要, 这些参数和返回值并不是任何类型.下面是些AIDL支持的数据类型:

1. 不需要import声明的简单Java编程语言类型(int,boolean等)

2. String, CharSequence不需要特殊声明

3. List, Map和Parcelables类型, 这些类型内所包含的数据成员也只能是简单数据类型, String等其他比支持的类型.

(另外: 我没尝试Parcelables, 在Eclipse+ADT下编译不过, 或许以后会有所支持)
```

<h2 id="请解释下Android程序运行时权限与文件系统权限的区别。">
请解释下Android程序运行时权限与文件系统权限的区别。
<a href="#" >
(更多参考)</a></h2>

[回到目录](#目录)

```
答：运行时权限Dalvik( android授权)

文件系统 linux 内核授权
```


<h2 id="Android的dvm中进程和Linux的进程,应用程序的进程是否为同一个概念">
Android的dvm中进程和Linux的进程,应用程序的进程是否为同一个概念
<a href="#" >
(更多参考)</a></h2>

[回到目录](#目录)

```
DVM指dalivk的虚拟机。每一个Android应用程序都在它自己的进程中运行，都拥有一个独立的Dalvik虚拟机实例。而每一个DVM都是在Linux 中的一个进程，所以说可以认为是同一个概念。
```


<h2 id="谈谈Android的IPC（进程间通信）机制">
谈谈Android的IPC（进程间通信）机制
<a href="#" >
(更多参考)</a></h2>

[回到目录](#目录)

```
IPC是内部进程通信的简称， 是共享"命名管道"的资源。Android中的IPC机制是为了让Activity和Service之间可以随时的进行交互，故在Android中该机制，只适用于Activity和Service之间的通信，类似于远程方法调用，类似于C/S模式的访问。通过定义AIDL接口文件来定义IPC接口。Servier端实现IPC接口，Client端调用IPC接口本地代理。
```


<h2 id="NDK是什么">
NDK是什么
<a href="#" >
(更多参考)</a></h2>

[回到目录](#目录)

```
NDK是一些列工具的集合，NDK提供了一系列的工具，帮助开发者迅速的开发C/C++的动态库，并能自动将so和java 应用打成apk包。
NDK集成了交叉编译器，并提供了相应的mk文件和隔离cpu、平台等的差异，开发人员只需简单的修改mk文件就可以创建出so
```


<h2 id="StringBuilder与StringBuffer的区别">
StringBuilder与StringBuffer的区别
<a href="#" >
(更多参考)</a></h2>

[回到目录](#目录)

```
 1.StringBuilder：线程非安全的
 2.StringBuffer：线程安全的
 3.当我们在字符串缓冲去被多个线程使用是，JVM不能保证StringBuilder的操
作是安全的，虽然他的速度最快，但是可以保证StringBuffer是可以正确操
作的。当然大多数情况下就是我们是在单线程下进行的操作，所以大多数情况
下是建议用StringBuilder而不用StringBuffer的，就是速度的原因。
```


<h2 id="如何理解Activity，View，Window三者之间的关系？">
如何理解Activity，View，Window三者之间的关系？
<a href="#" >
(更多参考)</a></h2>

[回到目录](#目录)

```
这个问题真的很不好回答。所以这里先来个算是比较恰当的比喻来形容下它们的关系吧。Activity像一个工匠（控制单元），Window像窗户（承载模型），View像窗花（显示视图）LayoutInflater像剪刀，Xml配置像窗花图纸。

1：Activity构造的时候会初始化一个Window，准确的说是PhoneWindow。

2：这个PhoneWindow有一个“ViewRoot”，这个“ViewRoot”是一个View或者说ViewGroup，是最初始的根视图。

3：“ViewRoot”通过addView方法来一个个的添加View。比如TextView，Button等

4：这些View的事件监听，是由WindowManagerService来接受消息，并且回调Activity函数。比如onClickListener，onKeyDown等。
```


<h2 id="View的绘制流程">
View的绘制流程
<a href="http://blog.csdn.net/yanbober/article/details/46128379/" >
(更多参考)</a></h2>

[回到目录](#目录)

```
measure过程

layout过程

draw过程


```


<h2 id="Touch事件的传递机制">
Touch事件的传递机制
<a href="#" >
(更多参考)</a></h2>

[回到目录](#目录)

```
publicbooleandispatchTouchEvent(MotionEventev);  //用来分派event
publicbooleanonInterceptTouchEvent(MotionEventev);//用来拦截event
publicbooleanonTouchEvent(MotionEventev);//用来处理event
其中Activity和View控件（TextView）拥有分派和处理事件方法，View容器（LinearLayout）具有分派，拦截，处理事件方法。这里也有个比喻：领导都会把任务向下分派，一旦下面的人把事情做不好，就不会再把后续的任务交给下面的人来做了，只能自己亲自做，如果自己也做不了，就只能告诉上级不能完成任务，上级又会重复他的过程。另外，领导都有权利拦截任务，对下级隐瞒该任务，而直接自己去做，如果做不成，也只能向上级报告不能完成任务。

http://gold.xitu.io/entry/56af0ba0c24aa800547b60ea

http://blog.csdn.net/morgan_xww/article/details/9372285
```

# 、
```
```

# 、
```
```

# 、
```
```

# 、
```
```

# 、
```
```

# 、
```
```

# 、
```
```

# 、
```
```

# 、
```
```

# [等待整理](https://www.jianshu.com/p/a22450882af2)
```
8：Android中跨进程通讯有几种方式

1：访问其他应用程序的Activity
如调用系统通话应用

IntentcallIntent=newIntent(Intent.ACTION_CALL,Uri.parse("tel:12345678");
startActivity(callIntent);
2：Content Provider
如访问系统相册

3：广播（Broadcast）
如显示系统时间

4：AIDL服务

9：AIDL理解

http://bbs.51cto.com/thread-1086040-1.html

10：Handler的原理

http://blog.csdn.net/lmj623565791/article/details/38377229

11：Binder机制原理

http://blog.csdn.net/boyupeng/article/details/47011383

12：热修复的原理

1：JavaSisst
2：AspectJ
3：Xposef
这里给出Xposef方案
http://mp.weixin.qq.com/s?__biz=MzA3Mjk1MjA4Nw==&mid=400452659&idx=1&sn=841b49b875ec3b307f261ed52a7d9c4e&scene=23&srcid=1119JWRt0adNwGxTHiyok460#rd

13：设计一套图片异步加载缓存方案

http://www.cnblogs.com/zyw-205520/p/4997863.html
http://blog.csdn.net/boyupeng/article/details/47127605

14：Android内存泄露及管理

http://gold.xitu.io/entry/56d64b9e816dfa005943a55c

15：Activity与Fragment通信

http://gold.xitu.io/entry/56a87b2b2e958a0051906227

16：Fragment的那些坑

http://www.jianshu.com/p/d9143a92ad94
http://www.jianshu.com/p/fd71d65f0ec6
http://www.jianshu.com/p/38f7994faa6b

16：Android UI适配

这里给出hongyang大神的方案
http://blog.csdn.net/lmj623565791/article/details/45460089

17：布局优化

http://www.jianshu.com/p/145fc61011cd

18：Http Https

http://www.jianshu.com/p/93fdebe5fef1

19：网络请求优化

http://www.jianshu.com/p/3141d4e46240

20：数据库优化

http://www.jianshu.com/p/3b4452fc1bbd

21：图片优化

http://www.jianshu.com/p/5bb8c01e2bc7

22：HybridJAVA 与JS交互

http://droidyue.com/blog/2014/09/20/interaction-between-java-and-javascript-in-android/

23：单例

http://www.jianshu.com/p/a956024629cb

24：Java GC原理

http://www.jianshu.com/p/d75a32ac5bed?

25：ANR

http://www.jianshu.com/p/124f3b75e164

26：Volley

http://www.jianshu.com/p/9e17727f31a1

27：JAVA注解反射原理

http://www.jianshu.com/p/3968ffabdf9d

28：算法

http://www.jianshu.com/p/ae97c3ceea8d

29：设计模式

http://gold.xitu.io/entry/56ebb4ad5bbb50004c440972

30：RxJava

http://gank.io/post/560e15be2dca930e00da1083?from=timeline&isappinstalled=0#toc_1

```

# [等待整理2](http://blog.csdn.net/wdong_love_cl/article/details/52084720)
```
ndroid性能优化系列 http://www.trinea.cn/android/performance/


2016JAVA与Android面试题整理 http://www.nowcoder.com/discuss/3244

百度的android面试总结分析 http://blog.csdn.net/lpjishu/article/details/46425281

android面试题总结从初级到进阶 http://blog.csdn.net/vfush/article/details/51508098

android最全面试题71道详解 http://blog.csdn.net/superjunjin/article/details/7772030

四大组件跟Handler相关的知识 http://www.iwfu.me/2016/07/17/安卓面试题：1-关于activity/

Java线程面试题Top50 http://www.jcodecraeer.com/a/chengxusheji/java/2015/0206/2421.html

国内一线互联网公司内部面试题库 http://blog.csdn.net/wdong_love_cl/article/details/51989028

囊括了所有你能想到的面试题目 https://github.com/GeniusVJR/LearningNotes/blob/master/README.md



android面试资料集合(简历，试题，面试技巧等) http://www.jianshu.com/p/d1efe2f31b6d


40个Java集合面试问题和答案 http://www.jcodecraeer.com/a/chengxusheji/java/2015/0520/2896.html

Java开发中的23种设计模式详解 http://www.cnblogs.com/maowang1991/archive/2013/04/15/3023236.html

面试和算法心得 https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/Readme.md
```

# [Android面试回忆录](http://blog.csdn.net/theone10211024/article/details/51025022)
# [等待整理3](http://blog.csdn.net/ericpengjun/article/details/50902665)
```
以下是一些常用的Android面试题及答案，有需要没需要都可以备着，希望能帮到大家。


1. 请描述一下Activity 生命周期。

答: 如下图所示。共有七个周期函数，按顺序分别是: onCreate(), onStart(), onRestart(), onResume(), onPause(),onStop(), onDestroy()。

onCreate(): 创建Activity时调用，设置在该方法中，还以Bundle的形式提供对以前存储的任何状态的访问。

onStart(): Activity变为在屏幕上对用户可见时调用。

onResume(): Activity开始与用户交互时调用(无论是启动还是重新启动一个活动，该方法总是被调用。

onPause(): Activity被暂停或收回cpu和其他资源时调用，该方法用户保护活动状态的，也是保护现场。

onStop(): Activity被停止并转为不可见阶段及后续的生命周期事件时调用。

onRestart(): Activity被重新启动时调用。该活动仍然在栈中，而不是启动新的Activity。

1、完整生命周期: 即从一个Activity从出现到消失，对应的周期方法是从onCreate()到onDestroy()。

2、可见生命周期: 当Activity处于可以用户看见的状态，但不一定能与用户交互时，将多次执行从onStart()到onStop()。

3、前景生命周期: 当Activity处于Activity栈最顶端，能够与其他用户进行交互时，将多次执行从onResume()到onPause()。



2. 两个Activity之间跳转时必然会执行的是哪几个方法。

答: 两个Activity之间跳转必然会执行的是下面几个方法。

onCreate()//在Activity生命周期开始时调用。

onRestoreInstanceState()//用来恢复UI状态。

onRestart()//当Activity重新启动时调用。

onStart()//当Activity对用户即将可见时调用。

onResume()//当Activity与用户交互时，绘制界面。

onSaveInstanceState()//即将移出栈顶保留UI状态时调用。

onPause()//暂停当前活动Activity，提交持久数据的改变，停止动画或其他占用GPU资源的东西，由于下一个Activity在这个方法返回之前不会resume，所以这个方法的代码执行要快。

onStop()//Activity不再可见时调用。

onDestroy()//Activity销毁栈时被调用的最后一个方法。



3. 横竖屏切换时候Activity的生命周期。

答:

1、不设置Activity的android: configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次。

2、设置Activity的android: configChanges=“orientation”时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次。

3、设置Activity的android: configChanges=“orientation|keyboardHidden”时，切屏不会重新调用各个生命周期，只会执行onConfiguration方法



4. 如何将一个Activity设置成窗口的样式。

答: 第一种方法，在styles.xml文件中，可以新建如下的类似Dialog的style。

 。

第二种方法，在AndroidManifest.xml中在需要显示为窗口的Activity中添加如下属性:  android: theme=“@style/Theme.FloatActivity”即可。也可以直接添加对应需要展示为Dialog style的Activity的android: theme属性为android: theme=“@ android: style/Theme.Dialog”。



5. 两个Activity之间怎么传递数据？

答: 可以在Intent对象中利用Extra来传递存储数据。

在Intent的对象请求中，使用putExtra(“键值对的名字”，”键值对的值”)；在另外一个Activity中将Intent中的请求数据取出来:

Intent intent = getIntent();

String value = intent.getStringExtra(“testIntent”);



6. 怎么让在启动一个Activity是就启动一个service？

答: 首先定义好一个service，然后在Activity的onCreate里面进行连接并bindservice或者直接startService。



7. Activity怎么和service绑定，怎么在activity中启动自己对应的service？

答:

1、activity能进行绑定得益于Serviece的接口。为了支持Service的绑定，实现onBind方法。

2、Service和Activity的连接可以用ServiceConnection来实现。需要实现一个新的ServiceConnection，重现onServiceConnected和OnServiceDisconnected方法，一旦连接建立，就能得到Service实例的引用。

3、执行绑定，调用bindService方法，传入一个选择了要绑定的Service的Intent(显示或隐式)和一个你实现了的ServiceConnection的实例



8.什么是Service以及描述下它的生命周期。Service有哪些启动方法，有什么区别，怎样停用Service？

答: Android Service是运行在后台的代码，不能与用户交互，可以运行在自己的进程，也可以运行在其他应用程序进程的上下文里。需要通过某一个Activity或者Context对象来调用。Service有两个启动方法，分别是Context.startService()和Context.bindService()。如果在Service执行耗时的操作需要启动一个新线程来执行。

Android Service只继承了onCreate(), onStart(),onDestroy()三个方法，当我们第一次启动Service时，先后调用onCreate(), onStart()这两个方法，当停止Service时，则执行onDestroy()方法时。如果Service已经启动了，当我们再次启动Service时，不会再执行onCreate()方法，而是直接执行onStart()方法。



9. 什么时候使用Service？

答: 比如播放多媒体的时候，用户启动了其他Activity，这个时候程序要在后台继续播放，比如检测SD卡上文件的变化，再或者在后台记录你的地理信息位置的改变等等。



10. 请描述一下Intent 和 Intent Filter。

答: Intent在Android中被翻译为”意图”，他是三种应用程序基本组件-Activity，Service和broadcast receiver之间相互激活的手段。在调用Intent名称时使用ComponentName也就是类的全名时为显示调用。这种方式一般用于应用程序的内部调用，因为你不一定会知道别人写的类的全名。而Intent Filter是指意图过滤，不出现在代码中，而是出现在android Manifest文件中，以的形式。（有一个例外是broadcast receiver的intent
filter是使用Context.registerReceiver()来动态设定的，其中intent filter也是在代码中创建的）

一个intent有action，data，category等字段。一个隐式intent为了能够被某个intent filter接收，必须通过3个测试，一个intent为了被某个组件接收，则必须通过它所有的intent filter中的一个。



11. Intent传递数据时，可以传递哪些类型数据？

答: intent间传送数据一般有两种常用的方法: 1、extra 2、data。

extra可以用Intent.putExtra放入数据。新启动的Activity可用Intent.getExtras取出Bundle，然后用Bundles.getLong,getInt,getBoolean,getString等函数来取放进去的值。

Data则是传输url。url可以是指我们熟悉的http，ftp等网络地址，也可以指content来指向ContentProvider提供的资源。Intent.setData可以放入数据，Intent.getData可以取出数据。



12. 说说Activity，Intent，Service是什么关系 ？

答: 一个Activity通常是一个单独的屏幕，每一个Activity都被实现为一个单独的类，这些类都是从Activity基类中继承而来的。Activity类会显示由视图控件组成的用户接口，并对视图控件的事件做出响应。

Intent的调用是用来进行屏幕之间的切换。Intent描述应用想要做什么。Intent数据结构中两个最重要的部分是动作和动作对应的数据，一个动作对应一个动作数据。

Service是运行在后台的代码，不能与用户交互，可以运行在自己的进程里，也可以运行在其他应用程序进程的上下文里。需要一个Activity或者其他Context对象来调用。

Activity跳转Activity，Activity启动Service，Service打开Activity都需要Intent表明意图，以及传递参数，Intent是这些组件间信号传递的承载着。



13. 请描述一下BroadcastReceiver。

答: Broadcast Receiver用于接收并处理广播通知(broadcast announcements)。多数的广播是系统发起的，如地域变换、电量不足、来电短信等。程序也可以播放一个广播。程序可以有任意数量的broadcast receivers来响应它觉得重要的通知。Broadcast receiver可以通过多种方式通知用户: 启动activity、使用NotificationManager、开启背景灯、振动设备、播放声音等，最典型的是在状态栏显示一个图标，这样用户就可以点它打开看通知内容。通常我们的某个应用或系统本身在某些事件(电池电量不足、来电短信)来临时会广播一个Intent出去，我们利用注册一个broadcast
receiver来监听这些Intent并获取Intent中的数据。



14. 在manifest和代码中如何注册和使用 broadcast receiver 。

答: 在android的manifest中注册













在代码中注册

1、 IntentFilter filter = new IntentFilter(“com.forrest.action.mybroadcast”);//和广播中Intent的action对应;

2、 MyBroadcastReceiver br= new MyBroadcastReceiver();

3、 registerReceiver(br, filter);



15. 请介绍下ContentProvider是如何实现数据共享的。

答: 一个程序可以通过实现一个Content provider的抽象接口将自己的数据完全暴露出去，而且Content provider是以类似数据库中的表的方式将自己的数据暴露。Content provider存储和检索数据，通过它可以让所有的应用程序访问到，这也是应用程序之间唯一共享数据的方法。

要想使应用程序的数据公开化，可通过2种方法：创建一个数据自己的Content Provider或者将你的数据添加到一个已经存在的Content Provider中，前提是有相同数据类型并且有写入Content Provider的权限，Android提供了Content Resolverr，外界的程序可以通过Content Resolver接口访问Content Provider提供的数据。



16. 请介绍下Android的数据存储方式。

答: Android提供了5中存储数据的方式，分别是以下几种

1、使用Shared Preferences存储数据，用来存储key-value，pairs格式的数据，它是一个轻量级的键值存储机制，只可以存储基本数据类型。

2、使用文件存储数据，通过FileInputStream和FileOutputStream对文件进行操作。在Android中，文件是一个应用程序私有的，一个应用程序无法读写其他应用程序的文件。

3、使用SQLite数据库存储数据，Android提供的一个标准数据库，支持SQL语句。

4、使用Content Provider存储数据，是所有应用程序之间数据存储和检索的一个桥梁，它的作用就是使得各个应用程序之间实现数据共享。它是一个特殊的存储数据的类型，它提供了一套标准的接口用来获取数据，操作数据。系统也提供了音频、视频、图像和个人信息等几个常用的Content Provider。如果你想公开自己的私有数据，可以创建自己的Content Provider类，或者当你对这些数据拥有控制写入的权限时，将这些数据添加到Content Provider中实现共享。外部访问通过Content Resolver去访问并操作这些被暴露的数据。

5、使用网络存储数据



17. 请介绍下Android中常用的五种布局。

答: 最常用的布局方式为Absolute Layout、Relative Layout、Linear Layout、FrameLayout、TableLayout。其中Linear Layout和Relative Layout是最常用的方式，他们可以通过在xml配置文件或者代码中进行布局。

1、Frame Layout是最简单的布局方式，放置的控件都只能罗列到左上角，控件会有重叠，不能进行复杂的布局。

2、Linear Layout可以通过orientation属性设置线性排列的方向是垂直还是纵向的,每行或每列只有一个元素，可以进行复杂的布局。

3、Absolute Layout可以让子元素指定准确的x、y坐标值，并显示在屏幕上。Absolute Layout没有页边框，允许元素之间相互重叠。它是绝对坐标，所以在实际中不提倡使用。



4、Relative Layout允许子元素制定他们相对于其他元素或父元素的位置(通过ID制定)。因此，你可以以右对齐，或上下，或置于屏幕中央的形式来排列两个元素。元素按顺序排列，因此如果第一个元素在屏幕的中央，那么相对于这个元素的其他元素将以屏幕中央的相对位置来排列。这个是相对于Absolute Layout的，采用相对坐标，所以在实际中比较常用。

5、Table Layout将以子元素的位置分配到行或列。一个Table Layout由许多的Table Row组成，每个Table Row都会定义一个row。Table Layout容器不会显示row、column或者cell的边线框。每个row拥有0个或多个的cell； 和html中的table差不多。在实际中也经常使用。



18. 谈谈UI中， Padding和Margin有什么区别？

答: Padding是控件的内容相对控件的边缘的边距，而Margin是控件边缘相对于其他控件的边距。如下图所示：



19.  android本身的一些限制，比如apk包大小限制，读取大文件时的时间限。

答：apk包大小限制不好说，有的apk为100M，还是能装到手机上。一般的apk大小为5~10M左右。读取大文件的时间应该是在main线程里面，时间限制为5秒左右。



20. ListView如何提高其效率？

答:1、使用分页加载，不要一次性加载所有数据。

2、复用convertView。在getItemView中，判断converView是否为空，如果不为空，可复用。

3、异步加载图片。Item中如果包含有webimage，那么最好异步加载。

4、快速滑动时，不显示图片。当快速滑动列表(SCROLL_STATE_FLING)，item中的图片或获取需要消耗资源的view，可以不显示出来；而处于其他两种状态(SCROLL_STATE_IDLE和SCROLL_STATE_TOUCH_SCROLL)，则将那些view显示出来



21. Android程序与Java程序的区别？


区别

Java程序

Android程序

执行入口点

Main

Android Mainfest.xml配置文件中的intent-filter

UI

Frame·

Activity

是否基于配置文件

否

是

是否基于组件

否

是Activity，Service，Broadcast Receiver，Content Provider


22. 谈谈对Android NDK的理解。

答: android NDK是一套工具，允许Android应用开发者嵌入从C、C++源代码编译来的本地机器代码到各自的应用软件包中。

1、 NDK是一系列工具的集合。

NDK提供了一系列的工具，帮助开发者快速开发C（或C++）的动态库，并能自动将so和java应用一起打包成apk。这些工具对开发者帮助时巨大的。

NDK集成了交叉编辑器，并提供了相应的mk文件隔离CPU、平台、API等差异，开发人员只需要简单修改mk文件（指出“那些文件需要编译”、“编译特性要求”等），就可以创建出so。NDK可以自动将so和Java应用一起打包，极大的减轻了开发人员的打包工作。

2、NDK提供了一份稳定、功能有限的API头文件声明。这些API支持的功能非常有限，包含有：C标准库（libc）、标准数学库（libm）、压缩库（libz）、log库（liblog）。



23. 谈谈Android的优点和不足之处。

答: 优点如下所示：

1、android是开源、市场占有率大。

2、android能够有丰富的硬件选择。

3、android是一款基于Linux平台的开源操作系统，从而避免了专利壁垒，是一款完全免费的只能手机平台。

4、由于android是google开发的，因此能够无缝结合Google应用。

缺点如下所示：

1、安全与隐私。手机与互联网紧密联系，个人隐私很难得到保守。



24. Android系统中GC什么情况下会出现内存泄露呢？

答: 导致内存泄露主要的原因是，先前申请了内存空间而忘记了释放。如果程序中存在无用对象的引用，那么这些对象就会驻留内存，消耗内存，因为无法让垃圾回收器GC验证这些对象是否不再需要。如果存在对象的引用，这个对象就被定义为“有效的活动”，同时不会被释放。要确定对象所占内存将被回收，我们就要确认该对象不会再被使用。典型的做法是把对象数据成员设为null或者从集合中移除该对象。当出现以下情况时，会造成内存泄露:

1、 数据库的cursor没有关闭。

2、 构造adapter时，没有使用缓存contentview。

3、 Bitmap对象不使用时，采用recycle()释放内存。

4、 Activity中的对象的生命周期大于activity。

调试方法: DDMS==>HEAPSIZE==>dataobject==>[TotalSize]



25. Android UI中的View如何刷新。

答: Android中对View的更新方式有很多种，使用时要区分不同的应用场合。要分清的是：多线程和双缓冲。

1、不使用多线程和双缓冲

这种情况最简单，一般只希望View在发生改变时对UI进行重绘。你只需要Activity中显式调用View对象中的invalidate()方法即可。系统会自动调用View的onDraw()方法。

2、使用多线程和不使用双缓冲

这种情况下需要开启新的线程，新开的线程就不好访问View对象了。强行访问的话会报错：android.view.ViewRoot$ CalledFromWrongThreadException: only theoriginal thread that created a view hierarchy can touch its views。

这时候你需要创建一个继承了android.os.handler的子类，并重写handleMessage方法。Android.os.Handle是能发送和处理消息的，你需要在Activity中发出更新UI的消息，然后再你的Handler(可以使用匿名内部类)中处理消息(因为匿名内部类可以访问父类变量，你可以直接调用View对象中的invalidate()方法。也就是说：在新线程中创建并发送一个Message，然后在主线程中捕获、处理该消息。



3、使用多线程和双缓冲

Android的SurfaceView是View的子类，她同时也实现了双缓冲。你可以定义一个她的子类并实现Surfaceholder.Callback接口。由于SurfaceHolder.Callback接口，新线程就不要android.os.Handler帮忙了。SurfaceHolder中lockCanvas()方法可以锁定画布，绘制完新的图像后调用unlockCanvasand Post解锁。
```


# [腾讯Android面经](http://blog.csdn.net/KesarChen/article/details/53332157)
# [2017春招实习-Android开发面经-bat，td等公司](http://blog.csdn.net/qq_19431333/article/details/77884322)
# [2018腾讯Android面经（已拿offer）](http://blog.csdn.net/u013647453/article/details/78174716)
# []()
# []()