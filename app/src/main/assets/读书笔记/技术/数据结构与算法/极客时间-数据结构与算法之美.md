# 02 | 如何抓住重点，系统高效地学习数据结构与算法？
1. 数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法，数据结构是为算法服务的，算法要作用在特定的数据结构之上。
2. 必须掌握的10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；
3. 必须掌握的10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。
4. 学习技巧：
```
1. 边学边练，适度刷题
2. 多问、多思考、多互动
3. 打怪升级学习法(当你努力打到一定级别之后，每天看着自己的经验值、战斗力在慢慢提高，那种每天都在一点一点成长的成就感就不由自主地产生了)
4. 知识需要沉淀，不要想试图一下子掌握所有
```

![全部的数据结构和算法](https://upload-images.jianshu.io/upload_images/4143664-fb63c9f08670684e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


# 03 | 复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？
1. 数据结构和算法本身解决的是“快”和“省”的问题，即如何让代码运行得更快，如何让代码更省存储空间。所以，执行效率是算法一个非常重要的考量指标。常用的有时间、空间复杂度分析。
2. 大 O 复杂度表示法：T(n) = O(f(n)),T(n)表示代码执行的时间,n 表示数据规模的大小；f(n) 表示每行代码执行的次数总和。因为这是一个公式，所以用 f(n) 来表示。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。
```
列如： T(n) = O(2n+2)；T(n) = O(2n2+2n+3)
```
3. 大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。
4. 当 n 很大时，你可以把它想象成 10000、100000。而公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。我们只需要记录一个最大量级就可以了，如果用大 O 表示法表示刚讲的那两段代码的时间复杂度，就可以记为：T(n) = O(n)； T(n) = O(n2)。
5. 如何分析一段代码的时间复杂度？
    1. 只关注循环执行次数最多的一段代码;
    2. 加法法则：总复杂度等于量级最大的那段代码的复杂度;T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) =O(max(f(n), g(n)))[多段的循环代码]
    3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积;T(n)=T1(n)*T2(n)=O(f(n))*O(g(n))=O(f(n)*g(n))[嵌套的循环代码]
6. 复杂度量级(按数量级递增)：
```
多项式量级------
1. 常数阶：O(1); 只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 O(1)。一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。
2. 对数阶：O(㏒n); 变量 i 的取值就是一个等比数列【如：while (i <= n)  { i = i * 3; }】
3. 线性阶：O(n);
4. 线性对数阶：O(n ㏒n);如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn)，归并排序、快速排序的时间复杂度都是 O(nlogn)。
5. 平方阶：O(n²)，立方阶：O(n³)，...K次方阶：O(nⁿ)
非多项式量级------该类的算法问题叫作NP（Non-Deterministic Polynomial，非确定多项式）问题，当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法
6. 指数阶：O(2²);
7. 阶乘阶：O(n!);
```
7. O(m+n)、O(m*n)：m 和 n 是表示两个数据规模 ，加法法则失效应表示为：T1(m) + T2(n) = O(f(m) + g(n))。但是乘法法则继续有效：T1(m)*T2(n) = O(f(m) * f(n))
8. 时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系。类比：空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。
9. 常见的空间复杂度就是 O(1)、O(n)、O(n2 )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。
10. 复杂度分析法则
    1. 单段代码看高频：比如循环;
    2. 多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度;
    3. 嵌套代码求乘积：比如递归、多重循环等;
    4. 多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。


----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# 04 | 复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度
1. 最好情况时间复杂度（best case time complexity）：在最理想的情况下，执行这段代码的时间复杂度。
2. 最坏情况时间复杂度（worst case time complexity）：在最糟糕的情况下，执行这段代码的时间复杂度。
3. 平均情况时间复杂度（average case time complexity）：全称应该叫加权平均时间复杂度或者期望时间复杂度,需要考虑概率进行加权；
4. 只有同一块代码在不同的情况下，时间复杂度有量级的差距，我们才会使用这三种复杂度表示法来区分。
5. 均摊时间复杂度（amortized time complexity）：对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。


----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# 数据结构与算法学习书单
1. 《大话数据结构》：把理论讲得很有趣，不枯燥。而且每个数据结构和算法，作者都结合生活中的例子进行了讲解， 能让你有非常直观的感受。虽然这本书有 400 多页，但是花两天时间读完，应该是没问题的。如果你之前完全不懂数据结构和算法，可以先从这本书看起。
2. 《算法图解》：“像小说一样有趣的算法入门书”，主打“图解”，通俗易懂。它只有不到 200 页，所以内容比较少。作为入门，看看这本书，能让你对数据结构和算法有个大概的认识。
3. 《数据结构和算法分析》：国内外很多大学都拿这本书当作教材。这本书非常系统、全面、严谨，而且又不是特别难，适合对数据结构和算法有些了解，并且掌握了至少一门编程语言的同学。而且，这个作者也很用心。他用了三种语言，写了三个版本，分别是：《数据结构与算法分析 ：C 语言描述》《数据结构与算法分析：C++ 描述》《数据结构与算法分析：Java 语言描述》。
4. 《剑指 offer》：这本书几乎包含了所有常见的、经典的面试题。如果能搞懂这本书里的内容，应付一般公司的面试应该不成问题。
5. 《编程珠玑》：这本书的豆瓣评分非常高，有 9 分。这本书最大的特色就是讲了很多针对海量数据的处理技巧。这个可能是其他算法书籍很少涉及的。面试的时候，海量数据处理的问题也是经常会问的，特别是校招面试。不管是开拓眼界，还是应付面试，这本书都很值得一看。
6. 《编程之美》：这本书有多位作者，其中绝大部分是微软的工程师，所以书的质量很有保证。不过，这里面的算法题目稍微有点难，也不是很系统，这也是我把它归到面试这一部分的原因。如果你有一定基础，也喜欢钻研些算法问题，或者要面试 Google、Facebook 这样的公司，可以拿这本书里的题，先来自测一下。
7. 适合闲暇时间阅读的书：《算法帝国》《数学之美》《算法之美》


----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# 05 | 数组：为什么很多编程语言中数组都从0开始编号？
1. 数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。
2. 除了数组，链表、队列、栈等也是线性表结构。非线性表，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。
3. 数组支持任意访问，根据下标任意访问的时间复杂度为 O(1)。“链表适合插入、删除，时间复杂度 O(1)；
4.	低效的插入和删除
    1. 插入：从最好O(1)， 最坏O(n)， 平均O(n)；
    2. 高效插入：数组若无序，插入新的元素时，可以将第K个位置元素移动到数组末尾，把新的元素，插入到第k个位置，此处复杂度为O(1)。
    3. 删除：从最好O(1) 最坏O(n) 平均O(n)
    4. 高效删除：标记已删除的元素，多次删除集中在一起，提高删除效率,记录下已经被删除的数据，每次的删除操作并不是搬移数据，只是记录数据已经被删除，当数组没有更多的存储空间时，再触发一次真正的删除操作。即JVM标记清除垃圾回收算法。
5.	容器能否完全替代数组，相比于数组，java中的ArrayList封装了数组的很多操作，并支持动态扩容。一旦超过容器容量，扩容时比较耗内存，因为涉及到内存申请和数据搬移。
    数组适合的场景：
    1. Java ArrayList 的使用涉及装箱拆箱，有一定的性能损耗，如果特别关注性能，可以考虑数组
    2. 若数据大小事先已知，并且涉及的数据操作非常简单，可以使用数组
    3. 表示多维数组时，数组往往更加直观。
    4. 业务开发使用容器即可，底层开发，如网络框架，性能优化。选择数组。
6. 回答标题：从偏移角度理解a[0] 0为偏移量，如果从1计数，会多出K-1，增加cpu负担；也有一定的历史原因
7. JVM标记清除算法：大多数主流虚拟机采用可达性分析算法来判断对象是否存活，在标记阶段，会遍历所有 GC ROOTS，将所有 GC ROOTS 可达的对象标记为存活。只有当标记工作完成后，清理工作才会开始。
    不足：1.效率问题。标记和清理效率都不高，但是当知道只有少量垃圾产生时会很高效。2.空间问题。会产生不连续的内存空间碎片。

![线性表](https://upload-images.jianshu.io/upload_images/4143664-c3a3d3d6913f09e7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![非线性表](https://upload-images.jianshu.io/upload_images/4143664-745c6b44f24d9909.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# 06 | 链表（上）：如何实现LRU缓存淘汰算法?
1. 单链表： 链表通过指针将一组零散的内存块串联在一起。其中，我们把内存块称为链表的“结点”。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址。我们把这个记录下个结点地址的指针叫作后继指针 next。头结点用来记录链表的基地址。有了它，我们就可以遍历得到整条链表。而尾结点特殊的地方是：指针不是指向下一个结点，而是指向一个空地址 NULL，表示这是链表上最后一个结点。
2. 循环链表：是一种特殊的单链表，尾结点指针是指向链表的头结点。
3. 双向链表：它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。
4. 双向循环链表:双向链表与循环链表的结合；
5. 时空转换：对于执行较慢的程序，可以通过消耗更多的内存（空间换时间）来进行优化；而消耗过多内存的程序，可以通过消耗更多的时间（时间换空间）来降低内存的消耗。

#### 一、什么是链表？
1. 和数组一样，链表也是一种线性表。
2. 从内存结构来看，链表的内存结构是不连续的内存空间，是将一组零散的内存块串联起来，从而进行数据存储的数据结构。
3. 链表中的每一个内存块被称为节点Node。节点除了存储数据外，还需记录链上下一个节点的地址，即后继指针next。
#### 二、为什么使用链表？即链表的特点
1. 插入、删除数据效率高O(1)级别（只需更改指针指向即可），随机访问效率低O(n)级别（需要从链头至链尾进行遍历）。
2. 和数组相比，内存空间消耗更大，因为每个存储数据的节点都需要额外的空间存储后继指针。
#### 三、常用链表：单链表、循环链表和双向链表
1. 单链表
    1. 每个节点只包含一个指针，即后继指针。
    2. 单链表有两个特殊的节点，即首节点和尾节点。为什么特殊？用首节点地址表示整条链表，尾节点的后继指针指向空地址null。
    3. 性能特点：插入和删除节点的时间复杂度为O（1），查找的时间复杂度为O(n)。
2. 循环链表
    1. 除了尾节点的后继指针指向首节点的地址外均与单链表一致。
    2. 适用于存储有循环特点的数据，比如约瑟夫问题。
3. 双向链表
    1. 节点除了存储数据外，还有两个指针分别指向前一个节点地址（前驱指针prev）和下一个节点地址（后继指针next）。
    2. 首节点的前驱指针prev和尾节点的后继指针均指向空地址。
    3. 性能特点：和单链表相比，存储相同的数据，需要消耗更多的存储空间。插入、删除操作比单链表效率更高O(1)级别。以删除操作为例，删除操作分为2种情况：给定数据值删除对应节点和给定节点地址删除节点。对于前一种情况，单链表和双向链表都需要从头到尾进行遍历从而找到对应节点进行删除，时间复杂度为O(n)。对于第二种情况，要进行删除操作必须找到前驱节点，单链表需要从头到尾进行遍历直到p->next = q，时间复杂度为O(n)，而双向链表可以直接找到前驱节点，时间复杂度为O(1)。对于一个有序链表，双向链表的按值查询效率要比单链表高一些。因为我们可以记录上次查找的位置p，每一次查询时，根据要查找的值与p的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。
4. 双向循环链表：首节点的前驱指针指向尾节点，尾节点的后继指针指向首节点。
#### 四、选择数组还是链表？
1. 插入、删除和随机访问的时间复杂度
    1. 数组：插入、删除的时间复杂度是O(n)，随机访问的时间复杂度是O(1)。
    2. 链表：插入、删除的时间复杂度是O(1)，随机访问的时间复杂端是O(n)。
2. 数组缺点
    1. 若申请内存空间很大，比如100M，但若内存空间没有100M的连续空间时，则会申请失败，尽管内存可用空间超过100M。
    2. 大小固定，若存储空间不足，需进行扩容，一旦扩容就要进行数据复制，而这时非常费时的。
3. 链表缺点
    1. 内存空间消耗更大，因为需要额外的空间存储指针信息。
    2. 对链表进行频繁的插入和删除操作，会导致频繁的内存申请和释放，容易造成内存碎片，如果是Java语言，还可能会造成频繁的GC（自动垃圾回收器）操作。
4. 如何选择？
数组简单易用，在实现上使用连续的内存空间，可以借助CPU的缓冲机制预读数组中的数据，所以访问效率更高，而链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法预读。
如果代码对内存的使用非常苛刻，那数组就更适合。

![单链表](https://upload-images.jianshu.io/upload_images/4143664-58bcf0d4ca4e2f83.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![循环链表](https://upload-images.jianshu.io/upload_images/4143664-6011cb40d5e38d70.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![双向链表](https://upload-images.jianshu.io/upload_images/4143664-5447767014886e6a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![数组与链表操作的时间复杂度](https://upload-images.jianshu.io/upload_images/4143664-6b1614e896a477a9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# 07 | 链表（下）：如何轻松写出正确的链表代码？

### 几个写链表代码技巧
1. 理解指针或引用的含义;
> 将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。
2. 技巧二：警惕指针丢失和内存泄漏;
> 插入结点时，一定要注意操作的顺序，要先将结点 x 的 next 指针指向结点 b，再把结点 a 的 next 指针指向结点 x，这样才不会丢失指针，导致内存泄漏. 同理，删除链表结点时，也一定要记得手动释放内存空间
3. 技巧三：利用哨兵简化实现难度;
```
1. 单链表的插入操作
if (head == null) {//空链表
    head = new_node;
}else{
    new_node->next = p->next;
    p->next = new_node;
}

2. 单链表的删除操作
if (head->next == null) {//要删除链表中的最后一个结点
    head = null;
}else{
    p->next = p->next->next;
}

```
> 针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理,如果我们引入哨兵结点，在任何时候，不管链表是不是空，head 指针都会一直指向这个哨兵结点。我们也把这种有哨兵结点的链表叫 **带头链表**。相反，没有哨兵结点的链表就叫作不带头链表。我画了一个带头链表[见下图]，你可以发现，哨兵结点是不存储数据的。因为哨兵结点一直存在，所以插入第一个结点和插入其他结点，删除最后一个结点和删除其他结点，都可以统一为相同的代码实现逻辑了。
4. 技巧四：重点留意边界条件处理
    1. 如果链表为空时，代码是否能正常工作？
    2. 如果链表只包含一个结点时，代码是否能正常工作？
    3. 如果链表只包含两个结点时，代码是否能正常工作？
    4. 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？

5. 技巧五：举例画图，辅助思考;
6. 技巧六：多写多练，没有捷径:
7. 5 个常见的链表操作:
A. 单链表反转;
```
    public Node inverseLinkList(Node head) {//将头结点为head的链表进行反转,返回反转后的头结点的链表
        Node pre_node = null;
        Node cur_node = head;
        Node nex_node = null;
        if (head == null || head.next == null)  return head;
        while (cur_node != null) {
            nex_node = cur_node.next;
            cur_node.next = pre_node;
            pre_node = cur_node;
            cur_node = nex_node;
        }
        return  pre_node;
    }
```

B. 链表中环的检测;
```
    /**
     * 检测链表中的环形: 快慢指针法
     * 首先设置两个指针，分别命名为fast和slow，fast指针每次向后移2步，slow指针每次向后移1步。如果，fast指针最后走到尾结点，则没有环。如果，fast指针和slow指针相遇，则证明有环。
     * 环的起始结点的查询: 当fast与slow相遇之后，fast指针从头结点开始走，每次走1步,当fast再次与slow相遇以后，相遇处的结点为环的入口结点
     *
     * @param head 待检测的链表
     * @return 环结点的入口, null表示无环结点
     */
    public Node checkLinkRing_v1(final Node head) {
        Node ringIn_node = null;
        if (head == null || head.next == null || head.next.next == null) {
            return null;
        }
        Node fast_node = head;
        Node slow_node = head;
        int count = 0;//相遇的次数
        while (fast_node != null && slow_node != null) {
            if (fast_node.next == null) {//走到了尾结点,不可能有环
                break;
            }
            if (ringIn_node == null) {
                fast_node = fast_node.next.next;
            } else {
                if (count == 1) {
                    fast_node = head;
                }
                fast_node = fast_node.next;
            }
            slow_node = slow_node.next;
            if (fast_node == slow_node) {
                count++;
                ringIn_node = fast_node;
                if (count == 2) {
                    break;
                }
            }
        }
        return ringIn_node;
    }

    /**
     * 足迹法: 顺序遍历链表中所有的节点，并将所有遍历过的节点信息保存下来。如果某个节点的信息出现了两次，则存在环。
     * @param head
     * @return
     */
    public boolean checkLinkRing_v2(final Node head) {
        boolean result = false;
        HashMap<Node, Node> map = new HashMap<>();
        Node p = head;
        while (p != null) {
            if (map.containsKey(p)) {
                return true;
            }
            map.put(p, p);
            p = p.next;
        }
        return result;
    }
```

C. 两个有序的链表合并;
```
    /**
     * 通过比较,每次只拷贝小的数据到合并后的链表中,原有链表结构不会被破坏
     *
     * @param h1
     * @param h2
     * @return 合并后的链表的头
     */
    public static Node mergeOrderlyLink_v1(final Node h1, final Node h2) {
        Node tem = h1 != null ? h1 : h2;
        if (h1 == null || h2 == null) {
            return tem;
        }
        Node merge = null;
        Node p1 = h1, p2 = h2;
        Node pm = new Node(-1, null);//自定义一个头结点
        int i = 0;
        while (p1 != null && p2 != null) {//比较大小,将小的拷贝到合并后的链表中
            if (p1.data <= p2.data) {
                pm.next = new Node(p1.data, null);
                p1 = p1.next;
            } else {
                pm.next = new Node(p2.data, null);
                p2 = p2.next;
            }
            if (i == 0) {
                merge = pm;
            }
            pm = pm.next;
            i++;
        }
        tem = p1 == null ? p2 : p1;
        while (tem != null) {//拷贝剩余的数据追加到合并后的链表中
            pm.next = new Node(tem.data, null);
            pm = pm.next;
            tem = tem.next;
        }
        merge = merge.next;//去除自定义的头结点
        return merge;
    }

    /**
     * 递归合并有序链表,原有链表结构会被破坏,数据较大时容易发生堆栈溢出异常,
     * 说明参考链接:https://blog.csdn.net/fengpojian/article/details/81384130实现
     *
     * @param h1
     * @param h2
     * @return
     */
    public static Node mergeOrderlyLink_v2(final Node h1, final Node h2) {
        Node tem = h1 != null ? h1 : h2;
        if (h1 == null || h2 == null) {
            return tem;
        }
        Node merge = null;
        if (h1.data <= h2.data) {
            merge = h1;
            merge.next = mergeOrderlyLink_v2(h1.next, h2);
        } else {
            merge = h2;
            merge.next = mergeOrderlyLink_v2(h1, h2.next);
        }
        return merge;
    }
```

D. 删除链表倒数第 n 个结点(n 保证有效);
```
    /**
     * 一次遍历法: 使用快慢指针。快指针比慢指针提前n个单元。当快指针到达单链表尾部时，慢指针指向待删除节点的前节点。
     *
     * @param head
     * @param beforIndex 保证有效,从 1 开始
     * @return
     */
    public static Node deleteIndexFormEnd_v2(final Node head, int beforIndex) {
        Node fast = head;
        Node slow = head;
        for (int i = 0; i < beforIndex; i++) {
            fast = fast.next;
        }
        if (fast == null) {
            return head.next;
        }
        while (fast.next != null) {
            fast = fast.next;
            slow = slow.next;
        }
        slow.next = slow.next.next;
        return head;
    }

    /**
     * 常规做法: 遍历第一次求出链表的长度,遍历第二次删除
     *
     * @param head
     * @param beforIndex 保证有效,从 1 开始
     * @return
     */
    public static Node deleteIndexFormEnd_v1(final Node head, int beforIndex) {
        int size = 0;
        Node p = head;
        while (p != null) {
            p = p.next;
            size++;
        }
        if (beforIndex == size) {//删除头结点
            return head.next;
        }
        int count = 0;
        int k = size - beforIndex;
        p = head;//复位
        Node pre = p; //记录要寻找到的删除的结点的上结点
        while (p != null) {
            if (count == k) {//找到要删除的结点
                pre.next = p.next;
                break;
            }
            pre = p;
            p = p.next;
            count++;
        }
        return head;
    }
```
E. 求链表的中间结点;
```
    /**
     * 寻找链表的中间结点: 设置两个指针，一个快指针，每次走两步，一个慢指针，每次走一步。
     * 常规做法: 先遍历整个链表求长度在遍历一次找到中间结点,代码省略
     *
     * @param head
     * @return
     */
    public static Node findCenterNode(Node head) {
        Node slow = head;
        Node fast = head;
        while (fast != null && fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }
```



![带头链表.jpg](https://upload-images.jianshu.io/upload_images/4143664-b9dd4cf533b6cbf8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# 08 | 栈：如何实现浏览器的前进和后退功能？
1. 后进者先出，先进者后出，这就是典型的“栈”结构。栈是一种“操作受限”的线性表，只允许在一端插入和删除数据。当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选“栈”这种数据结构。
2. 栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫作顺序栈，用链表实现的栈，我们叫作链式栈。
3. 栈的应用:
    1. **栈在函数调用中的应用:** 操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构，用来存储函数调用时的临时变量。每进入一个函数，就会将其中的临时变量作为栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。
    2. **栈在表达式求值中的应用:** 编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。
    3. **栈在括号匹配中的应用:** 用栈保存为匹配的左括号，从左到右一次扫描字符串，当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号，如果能匹配上，则继续扫描剩下的字符串。如果扫描过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明未匹配的左括号为非法格式。
    4. **浏览器的前进和后退:** 使用两个栈，X 和 Y，我们把首次浏览的页面依次压入栈 X，当点击后退按钮时，再依次从栈 X 中出栈，并将出栈的数据依次放入栈 Y。当我们点击前进按钮时，我们依次从栈 Y 中取出数据，放入栈 X 中。当栈 X 中没有数据时，那就说明没有页面可以继续后退浏览了。当栈 Y 中没有数据，那就说明没有页面可以点击前进按钮浏览了。
4. 不管基于数组还是链表，入栈、出栈的时间复杂度和空间复杂度都为 O(1)。
5. 我们都知道，JVM 内存管理中有个“堆栈”的概念。栈内存用来存储局部变量和方法调用，堆内存用来存储 Java 中的对象。那 JVM 里面的“栈”跟我们这里说的“栈”是不是一回事呢？如果不是，那它为什么又叫作“栈”呢？
> 内存中的堆栈和数据结构堆栈不是一个概念，可以说内存中的堆栈是真实存在的物理区，数据结构中的堆栈是抽象的数据存储结构。
  内存空间在逻辑上分为三部分：代码区、静态数据区和动态数据区，动态数据区又分为栈区和堆区。
  代码区：存储方法体的二进制代码。高级调度（作业调度）、中级调度（内存调度）、低级调度（进程调度）控制代码区执行代码的切换。
  静态数据区：存储全局变量、静态变量、常量，常量包括final修饰的常量和String常量。系统自动分配和回收。
  栈区：存储运行方法的形参、局部变量、返回值。由系统自动分配和回收。
  堆区：new一个对象的引用或地址存储在栈区，指向该对象存储在堆区中的真实数据。
6. 为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？
> 其实，我们不一定非要用栈来保存临时变量，只不过如果这个函数调用符合后进先出的特性，用栈这种数据结构来实现，是最顺理成章的选择。从调用函数进入被调用函数，对于数据来说，变化的是什么呢？是作用域。所以根本上，只要能保证每进入一个新的函数，都是一个新的作用域就可以。而要实现这个，用栈就非常方便。在进入被调用函数的时候，分配一段栈空间给这个函数的变量，在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内。



![栈在表达式求值中的应用.jpg](https://upload-images.jianshu.io/upload_images/4143664-3a1055d462a4efef.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# 09 | 队列：队列在线程池等有限资源池中的应用
1. 先进者先出，这就是典型的“队列”。队列跟栈非常相似，支持的操作也很有限，最基本的操作也是两个：入队 enqueue()，放一个数据到队列尾部；出队 dequeue()，从队列头部取一个元素。队列跟栈一样，也是一种操作受限的线性表数据结构。
2. 用数组实现的队列叫作顺序队列，用链表实现的队列叫作链式队列。
3. 队列的满空判断
```
//TODO 普通顺序非循环队列,第一种
            if (tail >= items.length) {//队列满了
                return false;
            }
            if (head >= tail) {//队列已经空了
                return null;
            }
//TODO 普通顺序非循环队列,第二种,优化第一种
            if (size == items.length) { //队列满了
                return false;
            }
            if (tail == items.length && size < items.length) {//队尾指针移动到了最后,但是队列未满,搬移队列内的元素
                for (int i = 0; i < size; i++) {
                    items[i] = items[head++];
                }
                tail = size;
                head = 0;
            }
            if (head >= tail) {
                return null;
            }
//TODO 循环队列
        public boolean enqueue(String val) {
            if (size == items.length) { //队列满了
                return false;
            }
            if (tail == items.length && size < items.length) {//队尾指针移动到了最后,但是队列未满,重置队尾指针
                tail = 0;
            }
        }
        public String dequeue() {
            if (size == 0) {
                System.out.println("队列空了");
                return null;
            }
            if (head == items.length && size() > 0) {//队头指针移到最后但是队列不为空
                head = 0;
            }
        }
```
4. **阻塞队列:** 其实就是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。
5. 线程安全的队列我们叫作**并发队列** 。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用 CAS[CAS的全称是Compare And Swap 即比较交换,线程安全的无锁策略] 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。
6. 基于链表的实现方式，可以实现一个支持无限排队的无界队列（unbounded queue），但是可能会导致过多的请求排队等待，请求处理的响应时间过长。所以，针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。
7. 基于数组实现的有界队列（bounded queue），队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。不过，设置一个合理的队列大小，也是非常有讲究的。队列太大导致等待的请求太多，队列太小会导致无法充分利用系统资源、发挥最大性能。
### Q-A
除了线程池这种池结构会用到队列排队请求，你还知道有哪些类似的池结构或者场景中会用到队列的排队请求呢？
>  分布式应用中的消息队列，也是一种队列结构

今天讲到并发队列，关于如何实现无锁并发队列，网上有非常多的讨论。对这个问题，你怎么看呢？
> 考虑使用CAS实现无锁队列，则在入队前，获取tail位置，入队时比较tail是否发生变化，如果否，则允许入队，反之，本次入队失败。出队则是获取head位置，进行cas。

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
