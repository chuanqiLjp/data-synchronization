# 02 | 如何抓住重点，系统高效地学习数据结构与算法？
1. 数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法，数据结构是为算法服务的，算法要作用在特定的数据结构之上。
2. 必须掌握的10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；
3. 必须掌握的10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。
4. 学习技巧：
```
1. 边学边练，适度刷题
2. 多问、多思考、多互动
3. 打怪升级学习法(当你努力打到一定级别之后，每天看着自己的经验值、战斗力在慢慢提高，那种每天都在一点一点成长的成就感就不由自主地产生了)
4. 知识需要沉淀，不要想试图一下子掌握所有
```

![全部的数据结构和算法](https://upload-images.jianshu.io/upload_images/4143664-fb63c9f08670684e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


# 03 | 复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？
1. 数据结构和算法本身解决的是“快”和“省”的问题，即如何让代码运行得更快，如何让代码更省存储空间。所以，执行效率是算法一个非常重要的考量指标。常用的有时间、空间复杂度分析。
2. 大 O 复杂度表示法：T(n) = O(f(n)),T(n)表示代码执行的时间,n 表示数据规模的大小；f(n) 表示每行代码执行的次数总和。因为这是一个公式，所以用 f(n) 来表示。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。
```
列如： T(n) = O(2n+2)；T(n) = O(2n2+2n+3)
```
3. 大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。
4. 当 n 很大时，你可以把它想象成 10000、100000。而公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。我们只需要记录一个最大量级就可以了，如果用大 O 表示法表示刚讲的那两段代码的时间复杂度，就可以记为：T(n) = O(n)； T(n) = O(n2)。
5. 如何分析一段代码的时间复杂度？
    1. 只关注循环执行次数最多的一段代码;
    2. 加法法则：总复杂度等于量级最大的那段代码的复杂度;T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) =O(max(f(n), g(n)))[多段的循环代码]
    3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积;T(n)=T1(n)*T2(n)=O(f(n))*O(g(n))=O(f(n)*g(n))[嵌套的循环代码]
6. 复杂度量级(按数量级递增)：
```
多项式量级------
1. 常数阶：O(1); 只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 O(1)。一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。
2. 对数阶：O(㏒n); 变量 i 的取值就是一个等比数列【如：while (i <= n)  { i = i * 3; }】
3. 线性阶：O(n);
4. 线性对数阶：O(n ㏒n);如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn)，归并排序、快速排序的时间复杂度都是 O(nlogn)。
5. 平方阶：O(n²)，立方阶：O(n³)，...K次方阶：O(nⁿ)
非多项式量级------该类的算法问题叫作NP（Non-Deterministic Polynomial，非确定多项式）问题，当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法
6. 指数阶：O(2²);
7. 阶乘阶：O(n!);
```
7. O(m+n)、O(m*n)：m 和 n 是表示两个数据规模 ，加法法则失效应表示为：T1(m) + T2(n) = O(f(m) + g(n))。但是乘法法则继续有效：T1(m)*T2(n) = O(f(m) * f(n))
8. 时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系。类比：空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。
9. 常见的空间复杂度就是 O(1)、O(n)、O(n2 )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。
10. 复杂度分析法则
    1. 单段代码看高频：比如循环;
    2. 多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度;
    3. 嵌套代码求乘积：比如递归、多重循环等;
    4. 多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。


----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# 04 | 复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度
1. 最好情况时间复杂度（best case time complexity）：在最理想的情况下，执行这段代码的时间复杂度。
2. 最坏情况时间复杂度（worst case time complexity）：在最糟糕的情况下，执行这段代码的时间复杂度。
3. 平均情况时间复杂度（average case time complexity）：全称应该叫加权平均时间复杂度或者期望时间复杂度,需要考虑概率进行加权；
4. 只有同一块代码在不同的情况下，时间复杂度有量级的差距，我们才会使用这三种复杂度表示法来区分。
5. 均摊时间复杂度（amortized time complexity）：对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。


----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# 数据结构与算法学习书单
1. 《大话数据结构》：把理论讲得很有趣，不枯燥。而且每个数据结构和算法，作者都结合生活中的例子进行了讲解， 能让你有非常直观的感受。虽然这本书有 400 多页，但是花两天时间读完，应该是没问题的。如果你之前完全不懂数据结构和算法，可以先从这本书看起。
2. 《算法图解》：“像小说一样有趣的算法入门书”，主打“图解”，通俗易懂。它只有不到 200 页，所以内容比较少。作为入门，看看这本书，能让你对数据结构和算法有个大概的认识。
3. 《数据结构和算法分析》：国内外很多大学都拿这本书当作教材。这本书非常系统、全面、严谨，而且又不是特别难，适合对数据结构和算法有些了解，并且掌握了至少一门编程语言的同学。而且，这个作者也很用心。他用了三种语言，写了三个版本，分别是：《数据结构与算法分析 ：C 语言描述》《数据结构与算法分析：C++ 描述》《数据结构与算法分析：Java 语言描述》。
4. 《剑指 offer》：这本书几乎包含了所有常见的、经典的面试题。如果能搞懂这本书里的内容，应付一般公司的面试应该不成问题。
5. 《编程珠玑》：这本书的豆瓣评分非常高，有 9 分。这本书最大的特色就是讲了很多针对海量数据的处理技巧。这个可能是其他算法书籍很少涉及的。面试的时候，海量数据处理的问题也是经常会问的，特别是校招面试。不管是开拓眼界，还是应付面试，这本书都很值得一看。
6. 《编程之美》：这本书有多位作者，其中绝大部分是微软的工程师，所以书的质量很有保证。不过，这里面的算法题目稍微有点难，也不是很系统，这也是我把它归到面试这一部分的原因。如果你有一定基础，也喜欢钻研些算法问题，或者要面试 Google、Facebook 这样的公司，可以拿这本书里的题，先来自测一下。
7. 适合闲暇时间阅读的书：《算法帝国》《数学之美》《算法之美》


----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# 05 | 数组：为什么很多编程语言中数组都从0开始编号？
1. 数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。
2. 除了数组，链表、队列、栈等也是线性表结构。非线性表，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。
3. 数组支持任意访问，根据下标任意访问的时间复杂度为 O(1)。“链表适合插入、删除，时间复杂度 O(1)；
4.	低效的插入和删除
    1. 插入：从最好O(1)， 最坏O(n)， 平均O(n)；
    2. 高效插入：数组若无序，插入新的元素时，可以将第K个位置元素移动到数组末尾，把新的元素，插入到第k个位置，此处复杂度为O(1)。
    3. 删除：从最好O(1) 最坏O(n) 平均O(n)
    4. 高效删除：标记已删除的元素，多次删除集中在一起，提高删除效率,记录下已经被删除的数据，每次的删除操作并不是搬移数据，只是记录数据已经被删除，当数组没有更多的存储空间时，再触发一次真正的删除操作。即JVM标记清除垃圾回收算法。
5.	容器能否完全替代数组，相比于数组，java中的ArrayList封装了数组的很多操作，并支持动态扩容。一旦超过容器容量，扩容时比较耗内存，因为涉及到内存申请和数据搬移。
    数组适合的场景：
    1. Java ArrayList 的使用涉及装箱拆箱，有一定的性能损耗，如果特别关注性能，可以考虑数组
    2. 若数据大小事先已知，并且涉及的数据操作非常简单，可以使用数组
    3. 表示多维数组时，数组往往更加直观。
    4. 业务开发使用容器即可，底层开发，如网络框架，性能优化。选择数组。
6. 回答标题：从偏移角度理解a[0] 0为偏移量，如果从1计数，会多出K-1，增加cpu负担；也有一定的历史原因

![线性表](https://upload-images.jianshu.io/upload_images/4143664-c3a3d3d6913f09e7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![非线性表](https://upload-images.jianshu.io/upload_images/4143664-745c6b44f24d9909.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
