# 02 | 如何抓住重点，系统高效地学习数据结构与算法？
1. 数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法，数据结构是为算法服务的，算法要作用在特定的数据结构之上。
2. 必须掌握的10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；
3. 必须掌握的10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。
4. 学习技巧：
```
1. 边学边练，适度刷题
2. 多问、多思考、多互动
3. 打怪升级学习法(当你努力打到一定级别之后，每天看着自己的经验值、战斗力在慢慢提高，那种每天都在一点一点成长的成就感就不由自主地产生了)
4. 知识需要沉淀，不要想试图一下子掌握所有
```

![全部的数据结构和算法](https://upload-images.jianshu.io/upload_images/4143664-fb63c9f08670684e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


# 03 | 复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？
1. 数据结构和算法本身解决的是“快”和“省”的问题，即如何让代码运行得更快，如何让代码更省存储空间。所以，执行效率是算法一个非常重要的考量指标。常用的有时间、空间复杂度分析。
2. 大 O 复杂度表示法：T(n) = O(f(n)),T(n)表示代码执行的时间,n 表示数据规模的大小；f(n) 表示每行代码执行的次数总和。因为这是一个公式，所以用 f(n) 来表示。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。
```
列如： T(n) = O(2n+2)；T(n) = O(2n2+2n+3)
```
3. 大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。
4. 当 n 很大时，你可以把它想象成 10000、100000。而公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。我们只需要记录一个最大量级就可以了，如果用大 O 表示法表示刚讲的那两段代码的时间复杂度，就可以记为：T(n) = O(n)； T(n) = O(n2)。
5. 如何分析一段代码的时间复杂度？
    1. 只关注循环执行次数最多的一段代码;
    2. 加法法则：总复杂度等于量级最大的那段代码的复杂度;T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) =O(max(f(n), g(n)))[多段的循环代码]
    3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积;T(n)=T1(n)*T2(n)=O(f(n))*O(g(n))=O(f(n)*g(n))[嵌套的循环代码]
6. 复杂度量级(按数量级递增)：
```
多项式量级------
1. 常数阶：O(1); 只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 O(1)。一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。
2. 对数阶：O(㏒n); 变量 i 的取值就是一个等比数列【如：while (i <= n)  { i = i * 3; }】
3. 线性阶：O(n);
4. 线性对数阶：O(n ㏒n);如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn)，归并排序、快速排序的时间复杂度都是 O(nlogn)。
5. 平方阶：O(n²)，立方阶：O(n³)，...K次方阶：O(nⁿ)
非多项式量级------该类的算法问题叫作NP（Non-Deterministic Polynomial，非确定多项式）问题，当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法
6. 指数阶：O(2²);
7. 阶乘阶：O(n!);
```
7. O(m+n)、O(m*n)：m 和 n 是表示两个数据规模 ，加法法则失效应表示为：T1(m) + T2(n) = O(f(m) + g(n))。但是乘法法则继续有效：T1(m)*T2(n) = O(f(m) * f(n))
8. 时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系。类比：空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。
9. 常见的空间复杂度就是 O(1)、O(n)、O(n2 )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。
10. 复杂度分析法则
    1. 单段代码看高频：比如循环;
    2. 多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度;
    3. 嵌套代码求乘积：比如递归、多重循环等;
    4. 多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。


----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# 04 | 复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度
1. 最好情况时间复杂度（best case time complexity）：在最理想的情况下，执行这段代码的时间复杂度。
2. 最坏情况时间复杂度（worst case time complexity）：在最糟糕的情况下，执行这段代码的时间复杂度。
3. 平均情况时间复杂度（average case time complexity）：全称应该叫加权平均时间复杂度或者期望时间复杂度,需要考虑概率进行加权；
4. 只有同一块代码在不同的情况下，时间复杂度有量级的差距，我们才会使用这三种复杂度表示法来区分。
5. 均摊时间复杂度（amortized time complexity）：对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。


----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# 数据结构与算法学习书单
1. 《大话数据结构》：把理论讲得很有趣，不枯燥。而且每个数据结构和算法，作者都结合生活中的例子进行了讲解， 能让你有非常直观的感受。虽然这本书有 400 多页，但是花两天时间读完，应该是没问题的。如果你之前完全不懂数据结构和算法，可以先从这本书看起。
2. 《算法图解》：“像小说一样有趣的算法入门书”，主打“图解”，通俗易懂。它只有不到 200 页，所以内容比较少。作为入门，看看这本书，能让你对数据结构和算法有个大概的认识。
3. 《数据结构和算法分析》：国内外很多大学都拿这本书当作教材。这本书非常系统、全面、严谨，而且又不是特别难，适合对数据结构和算法有些了解，并且掌握了至少一门编程语言的同学。而且，这个作者也很用心。他用了三种语言，写了三个版本，分别是：《数据结构与算法分析 ：C 语言描述》《数据结构与算法分析：C++ 描述》《数据结构与算法分析：Java 语言描述》。
4. 《剑指 offer》：这本书几乎包含了所有常见的、经典的面试题。如果能搞懂这本书里的内容，应付一般公司的面试应该不成问题。
5. 《编程珠玑》：这本书的豆瓣评分非常高，有 9 分。这本书最大的特色就是讲了很多针对海量数据的处理技巧。这个可能是其他算法书籍很少涉及的。面试的时候，海量数据处理的问题也是经常会问的，特别是校招面试。不管是开拓眼界，还是应付面试，这本书都很值得一看。
6. 《编程之美》：这本书有多位作者，其中绝大部分是微软的工程师，所以书的质量很有保证。不过，这里面的算法题目稍微有点难，也不是很系统，这也是我把它归到面试这一部分的原因。如果你有一定基础，也喜欢钻研些算法问题，或者要面试 Google、Facebook 这样的公司，可以拿这本书里的题，先来自测一下。
7. 适合闲暇时间阅读的书：《算法帝国》《数学之美》《算法之美》


----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# 05 | 数组：为什么很多编程语言中数组都从0开始编号？
1. 数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。
2. 除了数组，链表、队列、栈等也是线性表结构。非线性表，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。
3. 数组支持任意访问，根据下标任意访问的时间复杂度为 O(1)。“链表适合插入、删除，时间复杂度 O(1)；
4.	低效的插入和删除
    1. 插入：从最好O(1)， 最坏O(n)， 平均O(n)；
    2. 高效插入：数组若无序，插入新的元素时，可以将第K个位置元素移动到数组末尾，把新的元素，插入到第k个位置，此处复杂度为O(1)。
    3. 删除：从最好O(1) 最坏O(n) 平均O(n)
    4. 高效删除：标记已删除的元素，多次删除集中在一起，提高删除效率,记录下已经被删除的数据，每次的删除操作并不是搬移数据，只是记录数据已经被删除，当数组没有更多的存储空间时，再触发一次真正的删除操作。即JVM标记清除垃圾回收算法。
5.	容器能否完全替代数组，相比于数组，java中的ArrayList封装了数组的很多操作，并支持动态扩容。一旦超过容器容量，扩容时比较耗内存，因为涉及到内存申请和数据搬移。
    数组适合的场景：
    1. Java ArrayList 的使用涉及装箱拆箱，有一定的性能损耗，如果特别关注性能，可以考虑数组
    2. 若数据大小事先已知，并且涉及的数据操作非常简单，可以使用数组
    3. 表示多维数组时，数组往往更加直观。
    4. 业务开发使用容器即可，底层开发，如网络框架，性能优化。选择数组。
6. 回答标题：从偏移角度理解a[0] 0为偏移量，如果从1计数，会多出K-1，增加cpu负担；也有一定的历史原因
7. JVM标记清除算法：大多数主流虚拟机采用可达性分析算法来判断对象是否存活，在标记阶段，会遍历所有 GC ROOTS，将所有 GC ROOTS 可达的对象标记为存活。只有当标记工作完成后，清理工作才会开始。
    不足：1.效率问题。标记和清理效率都不高，但是当知道只有少量垃圾产生时会很高效。2.空间问题。会产生不连续的内存空间碎片。

![线性表](https://upload-images.jianshu.io/upload_images/4143664-c3a3d3d6913f09e7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![非线性表](https://upload-images.jianshu.io/upload_images/4143664-745c6b44f24d9909.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# 06 | 链表（上）：如何实现LRU缓存淘汰算法?
1. 单链表： 链表通过指针将一组零散的内存块串联在一起。其中，我们把内存块称为链表的“结点”。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址。我们把这个记录下个结点地址的指针叫作后继指针 next。头结点用来记录链表的基地址。有了它，我们就可以遍历得到整条链表。而尾结点特殊的地方是：指针不是指向下一个结点，而是指向一个空地址 NULL，表示这是链表上最后一个结点。
2. 循环链表：是一种特殊的单链表，尾结点指针是指向链表的头结点。
3. 双向链表：它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。
4. 双向循环链表:双向链表与循环链表的结合；
5. 时空转换：对于执行较慢的程序，可以通过消耗更多的内存（空间换时间）来进行优化；而消耗过多内存的程序，可以通过消耗更多的时间（时间换空间）来降低内存的消耗。

#### 一、什么是链表？
1. 和数组一样，链表也是一种线性表。
2. 从内存结构来看，链表的内存结构是不连续的内存空间，是将一组零散的内存块串联起来，从而进行数据存储的数据结构。
3. 链表中的每一个内存块被称为节点Node。节点除了存储数据外，还需记录链上下一个节点的地址，即后继指针next。
#### 二、为什么使用链表？即链表的特点
1. 插入、删除数据效率高O(1)级别（只需更改指针指向即可），随机访问效率低O(n)级别（需要从链头至链尾进行遍历）。
2. 和数组相比，内存空间消耗更大，因为每个存储数据的节点都需要额外的空间存储后继指针。
#### 三、常用链表：单链表、循环链表和双向链表
1. 单链表
    1. 每个节点只包含一个指针，即后继指针。
    2. 单链表有两个特殊的节点，即首节点和尾节点。为什么特殊？用首节点地址表示整条链表，尾节点的后继指针指向空地址null。
    3. 性能特点：插入和删除节点的时间复杂度为O（1），查找的时间复杂度为O(n)。
2. 循环链表
    1. 除了尾节点的后继指针指向首节点的地址外均与单链表一致。
    2. 适用于存储有循环特点的数据，比如约瑟夫问题。
3. 双向链表
    1. 节点除了存储数据外，还有两个指针分别指向前一个节点地址（前驱指针prev）和下一个节点地址（后继指针next）。
    2. 首节点的前驱指针prev和尾节点的后继指针均指向空地址。
    3. 性能特点：和单链表相比，存储相同的数据，需要消耗更多的存储空间。插入、删除操作比单链表效率更高O(1)级别。以删除操作为例，删除操作分为2种情况：给定数据值删除对应节点和给定节点地址删除节点。对于前一种情况，单链表和双向链表都需要从头到尾进行遍历从而找到对应节点进行删除，时间复杂度为O(n)。对于第二种情况，要进行删除操作必须找到前驱节点，单链表需要从头到尾进行遍历直到p->next = q，时间复杂度为O(n)，而双向链表可以直接找到前驱节点，时间复杂度为O(1)。对于一个有序链表，双向链表的按值查询效率要比单链表高一些。因为我们可以记录上次查找的位置p，每一次查询时，根据要查找的值与p的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。
4. 双向循环链表：首节点的前驱指针指向尾节点，尾节点的后继指针指向首节点。
#### 四、选择数组还是链表？
1. 插入、删除和随机访问的时间复杂度
    1. 数组：插入、删除的时间复杂度是O(n)，随机访问的时间复杂度是O(1)。
    2. 链表：插入、删除的时间复杂度是O(1)，随机访问的时间复杂端是O(n)。
2. 数组缺点
    1. 若申请内存空间很大，比如100M，但若内存空间没有100M的连续空间时，则会申请失败，尽管内存可用空间超过100M。
    2. 大小固定，若存储空间不足，需进行扩容，一旦扩容就要进行数据复制，而这时非常费时的。
3. 链表缺点
    1. 内存空间消耗更大，因为需要额外的空间存储指针信息。
    2. 对链表进行频繁的插入和删除操作，会导致频繁的内存申请和释放，容易造成内存碎片，如果是Java语言，还可能会造成频繁的GC（自动垃圾回收器）操作。
4. 如何选择？
数组简单易用，在实现上使用连续的内存空间，可以借助CPU的缓冲机制预读数组中的数据，所以访问效率更高，而链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法预读。
如果代码对内存的使用非常苛刻，那数组就更适合。

![单链表](https://upload-images.jianshu.io/upload_images/4143664-58bcf0d4ca4e2f83.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![循环链表](https://upload-images.jianshu.io/upload_images/4143664-6011cb40d5e38d70.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![双向链表](https://upload-images.jianshu.io/upload_images/4143664-5447767014886e6a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![数组与链表操作的时间复杂度](https://upload-images.jianshu.io/upload_images/4143664-6b1614e896a477a9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
